import os
from typing import NamedTuple, Dict, Set

from datetime import datetime, timedelta
from dateutil import parser  # type: ignore
import pytz  # type: ignore
from typing import Optional
from flask import Flask, jsonify, send_file, request, abort, Response
from pydantic import BaseModel, RootModel, ValidationError
import io
from urllib.request import urlopen
import icalendar
from apscheduler.schedulers.background import BackgroundScheduler  # type: ignore
import pathlib
import recurring_ical_events  # type: ignore

from csv_logger import CsvLogger
from render import render as label_render, next_update

import logging
logging.basicConfig(level=logging.INFO)


app = Flask(__name__)


class DeviceRecord(BaseModel):
  title: str
  ical_url: str
  template_filename: str
  ota_ver: int = 0  # OTA if reported version is less than this
  ota_filename: Optional[str] = None  # bytes of firmware .bin as generated by PlatformIO
  ota_after: Optional[datetime] = None  # only OTA after this time
  notes: str = ""  # comments, not used in code
  show_hours: bool = False  # whether to display hours


class ServerConfig(BaseModel):
  devices: Dict[str, DeviceRecord]
  admin_password: Optional[str] = None  # None or empty means admin functionality disabled


kConfigFilename = pathlib.Path('config/config.json')
try:
  with open(kConfigFilename) as f:
    config = ServerConfig.model_validate_json(f.read())
except ValidationError as e:  # load old-style config
  class DeviceMap(RootModel):
    root: Dict[str, DeviceRecord]
  with open(kConfigFilename) as f:
    devices_map = DeviceMap.model_validate_json(f.read())
  config = ServerConfig(devices=devices_map.root)
app.logger.info(f"Loaded config: {config}")

kHolidaysUrl = 'https://calendar.google.com/calendar/ical/en.usa%23holiday%40group.v.calendar.google.com/public/basic.ics'
kTimezone = pytz.timezone('America/Los_Angeles')
kCacheValidTime = timedelta(minutes=10)  # cache is stale after this time


PERSIST_DIR = "persist"
os.makedirs(PERSIST_DIR, exist_ok=True)

CSV_FILENAME = f"{PERSIST_DIR}/log.csv"
meta_csv = CsvLogger(CSV_FILENAME, ['timestamp', 'mac', 'vbat', 'fwVer', 'boot', 'rst', 'part', 'rssi',
                                    'lastDisplayTime'])


def filter_holiday_events(events: list[icalendar.Event]) -> list[icalendar.Event]:
  """Cleans up holidays and shortens names"""
  out = []
  for event in events:
    if 'first day of' in event.get('SUMMARY').lower():
      continue
    if 'Daylight Saving Time' in event.get('SUMMARY'):
      event['SUMMARY'] = event.get('SUMMARY').replace('Daylight Saving Time', 'DST')
    if '(' in event.get('SUMMARY'):
      event['SUMMARY'] = event.get('SUMMARY').split('(')[0].strip()
    out.append(event)
  return out

ota_done_devices: Set[str] = set()


class ICalCacheRecord(NamedTuple):
  fetch_time: datetime
  calendar: icalendar.Calendar

ical_cache: Dict[str, ICalCacheRecord] = {}


def get_cached_ical(url: str) -> icalendar.Calendar:
  record = ical_cache.get(url, None)
  fetch_time = datetime.now()
  if record is None or ((fetch_time - record.fetch_time) > kCacheValidTime):
    app.logger.info(f"cache: refill: {url}")
    data = urlopen(url).read()
    calendar: icalendar.Calendar = icalendar.Calendar.from_ical(data)  # type: ignore
    record = ICalCacheRecord(fetch_time, calendar)
    ical_cache[url] = record
  return record.calendar


scheduler = BackgroundScheduler()

def schedule_cache(url: str, title: str):
  starttime = datetime.now(kTimezone)
  ical_data = get_cached_ical(url)
  get_cached_ical(kHolidaysUrl)  # always update holidays
  nexttime = next_update(ical_data, title, True, starttime) - timedelta(minutes=5)
  app.logger.info(f"cache: next {url} at {nexttime}")
  scheduler.add_job(func=schedule_cache, args=[url, title], trigger="date", run_date=nexttime,
                    id=url, replace_existing=True)


for mac, device in config.devices.items():
  scheduler.add_job(func=schedule_cache, args=[device.ical_url, device.title],
                    trigger="date", run_date=datetime.now() + timedelta(seconds=3),
                    id=device.ical_url, replace_existing=True)
scheduler.start()


class MetaResponse(BaseModel):
  nextUpdateSec: int  # seconds to next update
  ota: bool = False  # whether to run OTA
  err: Optional[str] = None


@app.route("/version", methods=['GET'])
def version() -> str:
  return "0.4"


@app.route("/image", methods=['GET'])
def image() -> Response:
  try:
    starttime = datetime.now(kTimezone)

    rendertime = starttime
    force_time = request.args.get('forceTime', default=None)
    if force_time is not None:
      rendertime = parser.parse(force_time)
      if not rendertime.tzinfo:
        rendertime = rendertime.astimezone(kTimezone)

    device = config.devices[request.args.get('mac', default='')]
    all_cals = [get_cached_ical(device.ical_url)]
    holiday_events = filter_holiday_events(
      recurring_ical_events.of(get_cached_ical(kHolidaysUrl)).between(rendertime, rendertime + timedelta(days=2))
    )
    png_data = label_render(str(kConfigFilename.parent / device.template_filename),
                            all_cals, holiday_events, device.title, device.show_hours, rendertime)

    endtime = datetime.now(kTimezone)
    runtime = (endtime - starttime).seconds + (endtime - starttime).microseconds / 1e6

    title_printable = device.title.split('\n')[0]
    app.logger.info(f"render: {title_printable} ({runtime} s): {len(png_data)} B")

    return send_file(io.BytesIO(png_data), mimetype='image/png')
  except Exception as e:
    app.logger.exception(f"image: exception: {repr(e)}")
    abort(400)


@app.route("/meta", methods=['GET'])
def meta() -> Response:
  try:
    starttime = datetime.now(kTimezone)

    log_data = request.args.copy()
    log_data['timestamp'] = starttime.timestamp()
    meta_csv.log(log_data)

    rendertime = starttime
    force_time = request.args.get('forceTime', default=None)
    if force_time is not None:
      rendertime = parser.parse(force_time)
      if not rendertime.tzinfo:
        rendertime = rendertime.astimezone(kTimezone)

    device_mac = request.args.get('mac', default='')
    device = config.devices[device_mac]
    title_printable = device.title.split('\n')[0]
    ical_data = get_cached_ical(device.ical_url)
    nexttime = next_update(ical_data, device.title, device.show_hours, rendertime)
    next_update_sec = (nexttime - rendertime).seconds

    schedule_cache(device.ical_url, device.title)

    try:
      fwVer = int(request.args.get('fwVer', default=''))
    except ValueError:
      import sys
      fwVer = sys.maxsize
    run_ota = False
    if (device.ota_ver > fwVer) and (device.ota_filename is not None) \
        and (device.ota_after is None or rendertime >= device.ota_after):
      if device_mac not in ota_done_devices:
        run_ota = True
      else:
        app.logger.warning(f"ota: antiretry: {title_printable}")

    endtime = datetime.now().astimezone()
    runtime = (endtime - starttime).seconds + (endtime - starttime).microseconds / 1e6

    app.logger.info(f"meta: {title_printable} ({runtime} s): next {nexttime} ({next_update_sec} s)")

    response = MetaResponse(nextUpdateSec=next_update_sec, ota=run_ota)
    return jsonify(response.model_dump(exclude_none=True))
  except Exception as e:
    app.logger.exception(f"meta: exception: {repr(e)}")
    abort(400)


@app.route("/ota", methods=['GET'])
def ota() -> Response:
  try:
    device_mac = request.args.get('mac', default='')
    device = config.devices[device_mac]
    ota_done_devices.add(device_mac)
    title_printable = device.title.split('\n')[0]
    assert device.ota_filename is not None
    with open(kConfigFilename.parent / device.ota_filename, 'rb') as f:
      ota_data = f.read()
    app.logger.info(f"ota: {title_printable}: {len(ota_data)} B")

    return send_file(io.BytesIO(ota_data), mimetype='application/octet-stream')
  except Exception as e:
    app.logger.exception(f"ota: exception: {repr(e)}")
    abort(400)


@app.route("/admin/meta_csv", methods=['GET'])
def admin_meta_csv() -> Response:
  if not config.admin_password or request.args.get('password', default=None) != config.admin_password:
    abort(403)
  file_io = io.BytesIO(meta_csv.read().encode('utf-8'))
  return send_file(file_io, mimetype='text/csv')
